<!DOCTYPE html>
<html>
<head>
  <title>RideNDine V2 Live Routing Demo</title>
  <meta charset="utf-8"/>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <style>
    body { margin:0; font-family: Arial; }
    #map { height:100vh; }

    .panel {
      position:absolute;
      top:15px; left:15px;
      background:white;
      padding:15px;
      border-radius:12px;
      width:360px;
      z-index:999;
      box-shadow:0 0 12px rgba(0,0,0,0.35);
    }

    button {
      width:100%;
      padding:10px;
      margin-top:10px;
      border:none;
      border-radius:8px;
      font-weight:bold;
      cursor:pointer;
    }

    .run { background:#ff9800; }
    .clear { background:#ddd; }

    .small { font-size:13px; color:#333; }
  </style>
</head>

<body>

<div class="panel">
  <h2>RideNDine V2 Live Dispatch</h2>
  <p><b>Hamilton — Eastgate Square</b></p>

  <div class="small">
    ✅ Live driver movement simulation<br>
    ✅ Batched routes + animation<br>
    ✅ Ready for Mapbox/Google routing API upgrade
  </div>

  <button class="run" onclick="startLive()">Run Live Dispatch</button>
  <button class="clear" onclick="stopLive()">Clear Map</button>

  <p class="small" id="status"></p>
</div>

<div id="map"></div>

<script>
const eastgate = [43.2207, -79.7651];
const map = L.map("map").setView(eastgate, 12);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "© OpenStreetMap contributors"
}).addTo(map);

let cookMarkers = [];
let customerMarkers = [];
let driverMarkers = [];
let routeLines = [];
let animations = [];
let liveSocket = null;
let driverById = new Map();
let cookById = new Map();
let customerById = new Map();

function setStatus(text) {
  document.getElementById("status").innerHTML = text;
}

function clearMap() {
  [...cookMarkers, ...customerMarkers, ...driverMarkers, ...routeLines]
    .forEach(item => map.removeLayer(item));

  animations.forEach(anim => clearInterval(anim));

  cookMarkers = [];
  customerMarkers = [];
  driverMarkers = [];
  routeLines = [];
  animations = [];
  driverById.clear();
  cookById.clear();
  customerById.clear();
  setStatus("");
}

function stopLive() {
  if (liveSocket) {
    liveSocket.close();
    liveSocket = null;
  }
  clearMap();
}

function startLive() {
  clearMap();
  setStatus("Connecting to live GPS feed...");

  if (liveSocket) {
    liveSocket.close();
  }

  const wsUrl = "ws://localhost:8080";
  liveSocket = new WebSocket(wsUrl);

  liveSocket.onopen = () => {
    setStatus("Connected. Waiting for live dispatch data...");
  };

  liveSocket.onmessage = (event) => {
    let message;
    try {
      message = JSON.parse(event.data);
    } catch (err) {
      return;
    }

    if (message.type === "init") {
      renderInit(message.data);
      setStatus("✅ Live dispatch running: real-time driver GPS every 5s.");
    }

    if (message.type === "locations") {
      updateDrivers(message.data.drivers);
    }
  };

  liveSocket.onerror = () => {
    setStatus("❌ Live feed error. Is the server running?");
  };

  liveSocket.onclose = () => {
    setStatus("Disconnected from live feed.");
  };
}

function renderInit(data) {
  data.cooks.forEach((cook) => {
    const marker = L.marker([cook.lat, cook.lng]).addTo(map)
      .bindPopup("Cook #" + cook.id);
    cookMarkers.push(marker);
    cookById.set(cook.id, cook);
  });

  data.customers.forEach((customer) => {
    const marker = L.circleMarker([customer.lat, customer.lng], {
      radius:4,
      color:"blue",
      opacity:0.5
    }).addTo(map);
    customerMarkers.push(marker);
    customerById.set(customer.id, customer);
  });

  data.drivers.forEach((driver) => {
    const marker = L.circleMarker([driver.lat, driver.lng], {
      radius:8,
      color:"orange",
      fillColor:"orange",
      fillOpacity:1
    }).addTo(map)
      .bindPopup("Driver #" + driver.id);
    driverMarkers.push(marker);
    driverById.set(driver.id, marker);
  });

  data.orders.forEach((order) => {
    const cook = cookById.get(order.cookId);
    const customer = customerById.get(order.customerId);
    if (!cook || !customer) return;

    const line = L.polyline([[cook.lat, cook.lng], [customer.lat, customer.lng]], {
      color:"green",
      weight:2,
      opacity:0.4
    }).addTo(map);
    routeLines.push(line);
  });
}

function updateDrivers(drivers) {
  drivers.forEach((driver) => {
    const marker = driverById.get(driver.id);
    if (!marker) return;
    marker.setLatLng([driver.lat, driver.lng]);
  });
}
</script>

</body>
</html>
