const http = require("http");
const https = require("https");
const crypto = require("crypto");
const { URL } = require("url");

const PORT = 8080;
const EASTGATE = { lat: 43.2207, lng: -79.7651 };
const UPDATE_MS = 5000;

const NUM_COOKS = 10;
const ORDERS_PER_COOK = 20;
const NUM_DRIVERS = 20;
const MAX_BATCH = 4;
const DENSITY_RADIUS_KM = 2;
const BASE_FEE_CENTS = 199;
const PER_KM_FEE_CENTS = 120;
const SURGE_MULTIPLIER = 1.3;
const DEFAULT_OSRM = "https://router.project-osrm.org";
const DEFAULT_PROVIDER = process.env.ROUTING_PROVIDER_DEFAULT || "osrm";
const ROUTING_SERVER_NAME = process.env.ROUTING_SERVER_NAME || "RideNDine Demo Routing";
const START_TIME = Date.now();
const LAND_BOUNDS = {
  minLat: 43.08,
  maxLat: 43.27,
  minLng: -80.05,
  maxLng: -79.55,
};
const DEMO_TOKENS = new Map();
const DRIVER_LAST_UPDATE = new Map();
const DRIVER_STALE_MS = 15000;
const DRIVER_METRICS = new Map();
const DRIVER_SCORES = new Map();
const ALERTS = [];
const STATUS_FLOW = [
  { name: "accepted", seconds: 120 },
  { name: "preparing", seconds: 300 },
  { name: "ready", seconds: 120 },
  { name: "picked_up", seconds: 60 },
  { name: "delivering", seconds: 600 },
  { name: "delivered", seconds: 3600 },
];

function randomCoord(center, radiusKm) {
  for (let attempt = 0; attempt < 50; attempt += 1) {
    const r = radiusKm / 111;
    const u = Math.random();
    const v = Math.random();
    const w = r * Math.sqrt(u);
    const t = 2 * Math.PI * v;
    const x = w * Math.cos(t);
    const y = w * Math.sin(t);
    const candidate = { lat: center.lat + y, lng: center.lng + x };
    if (isLandSafe(candidate)) return candidate;
  }
  return clampToLand({ lat: center.lat, lng: center.lng });
}

function isLandSafe(coord) {
  return (
    coord.lat >= LAND_BOUNDS.minLat &&
    coord.lat <= LAND_BOUNDS.maxLat &&
    coord.lng >= LAND_BOUNDS.minLng &&
    coord.lng <= LAND_BOUNDS.maxLng
  );
}

function clampToLand(coord) {
  return {
    lat: Math.max(LAND_BOUNDS.minLat, Math.min(LAND_BOUNDS.maxLat, coord.lat)),
    lng: Math.max(LAND_BOUNDS.minLng, Math.min(LAND_BOUNDS.maxLng, coord.lng)),
  };
}

function makeId() {
  return crypto.randomBytes(4).toString("hex");
}

const cooks = [];
for (let i = 0; i < NUM_COOKS; i += 1) {
  cooks.push({ id: makeId(), ...randomCoord(EASTGATE, 5) });
}

const customers = [];
const orders = [];
for (let i = 0; i < cooks.length; i += 1) {
  for (let j = 0; j < ORDERS_PER_COOK; j += 1) {
    const customer = { id: makeId(), ...randomCoord(EASTGATE, 12) };
    customers.push(customer);
    orders.push({
      id: makeId(),
      cookId: cooks[i].id,
      customerId: customer.id,
      driverId: null,
      prepMinutes: 10 + Math.floor(Math.random() * 20),
      readyAt: Date.now() + (10 + Math.floor(Math.random() * 20)) * 60 * 1000,
    });
  }
}

const drivers = [];
for (let i = 0; i < NUM_DRIVERS; i += 1) {
  drivers.push({ id: makeId(), ...randomCoord(EASTGATE, 6) });
}

for (let i = 0; i < orders.length; i += 1) {
  orders[i].driverId = drivers[i % drivers.length].id;
  orders[i].status = "accepted";
}

drivers.forEach((driver) => {
  DRIVER_METRICS.set(driver.id, {
    cancellations: Math.floor(Math.random() * 3),
    lateDeliveries: Math.floor(Math.random() * 5),
    rating: 4 + Math.random(),
    completed: 20 + Math.floor(Math.random() * 80),
  });
});

refreshDriverScores();

function jitterLocation(driver) {
  const last = DRIVER_LAST_UPDATE.get(driver.id) || 0;
  if (Date.now() - last < DRIVER_STALE_MS) {
    return;
  }
  const deltaLat = (Math.random() - 0.5) * 0.0025;
  const deltaLng = (Math.random() - 0.5) * 0.0025;
  driver.lat += deltaLat;
  driver.lng += deltaLng;
}

function makeInitPayload() {
  updateOrderStatuses();
  refreshDriverScores();
  const batches = buildBatches();
  return {
    type: "init",
    data: {
      cooks,
      customers,
      orders,
      drivers,
      batches,
      driverScores: Object.fromEntries(DRIVER_SCORES),
    },
  };
}

function makeLocationPayload() {
  updateOrderStatuses();
  detectAlerts();
  return {
    type: "locations",
    data: {
      drivers: drivers.map((d) => ({ id: d.id, lat: d.lat, lng: d.lng })),
      orders: orders.map((o) => ({ id: o.id, status: o.status })),
      alerts: ALERTS,
    },
  };
}

function buildScopedPayload(role, orderId, driverId) {
  const base = makeLocationPayload();
  if (role === "customer" && orderId) {
    const order = orders.find((o) => o.id === orderId);
    if (!order) return base;
    return {
      ...base,
      data: {
        drivers: base.data.drivers.filter((d) => d.id === order.driverId),
        orders: base.data.orders.filter((o) => o.id === orderId),
      },
    };
  }

  if (role === "driver" && driverId) {
    return {
      ...base,
      data: {
        drivers: base.data.drivers.filter((d) => d.id === driverId),
        orders: base.data.orders.filter((o) => o.driverId === driverId),
      },
    };
  }

  return base;
}

function updateOrderStatuses() {
  const elapsed = Math.floor((Date.now() - START_TIME) / 1000);
  orders.forEach((order, index) => {
    const offset = (index * 7) % 300;
    let cursor = elapsed + offset;
    for (let i = 0; i < STATUS_FLOW.length; i += 1) {
      const step = STATUS_FLOW[i];
      if (cursor <= step.seconds) {
        order.status = step.name;
        return;
      }
      cursor -= step.seconds;
    }
    order.status = "delivered";
  });
}

function buildBatches() {
  const byCook = new Map();
  orders.forEach((order) => {
    if (!byCook.has(order.cookId)) byCook.set(order.cookId, []);
    byCook.get(order.cookId).push(order);
  });

  const batches = [];
  byCook.forEach((cookOrders, cookId) => {
    const cook = cooks.find((c) => c.id === cookId);
    if (!cook) return;

    // Cluster by distance to cook (density focus)
    const nearby = cookOrders.filter((order) => {
      const customer = customers.find((c) => c.id === order.customerId);
      if (!customer) return false;
      return haversine(cook, customer) <= DENSITY_RADIUS_KM;
    });
    const far = cookOrders.filter((order) => !nearby.includes(order));
    const ordered = [...nearby, ...far];

    for (let i = 0; i < ordered.length; i += MAX_BATCH) {
      const batchOrders = ordered.slice(i, i + MAX_BATCH);
      const driver = drivers[(batches.length + i) % drivers.length];
      batchOrders.forEach((o) => (o.driverId = driver.id));
      const stops = buildStops(driver, cook, batchOrders);
      batches.push({
        id: makeId(),
        driverId: driver.id,
        cookId,
        orderIds: batchOrders.map((o) => o.id),
        stops,
      });
    }
  });

  return batches;
}

function buildStops(driver, cook, batchOrders) {
  const stops = [];
  stops.push({ type: "driver", id: driver.id, lat: driver.lat, lng: driver.lng });
  stops.push({ type: "cook", id: cook.id, lat: cook.lat, lng: cook.lng });

  const remaining = batchOrders.map((order) => {
    const customer = customers.find((c) => c.id === order.customerId);
    return { orderId: order.id, customer };
  });

  let current = { lat: cook.lat, lng: cook.lng };
  while (remaining.length) {
    let bestIndex = 0;
    let bestDistance = Infinity;
    for (let i = 0; i < remaining.length; i += 1) {
      const target = remaining[i].customer;
      const distance = haversine(current, target);
      if (distance < bestDistance) {
        bestDistance = distance;
        bestIndex = i;
      }
    }
    const next = remaining.splice(bestIndex, 1)[0];
    stops.push({
      type: "customer",
      id: next.customer.id,
      orderId: next.orderId,
      lat: next.customer.lat,
      lng: next.customer.lng,
    });
    current = { lat: next.customer.lat, lng: next.customer.lng };
  }

  return stops;
}

function refreshDriverScores() {
  DRIVER_SCORES.clear();
  drivers.forEach((driver) => {
    const metrics = DRIVER_METRICS.get(driver.id) || {};
    const cancelPenalty = (metrics.cancellations || 0) * 8;
    const latePenalty = (metrics.lateDeliveries || 0) * 4;
    const ratingBonus = ((metrics.rating || 4.5) - 4) * 20;
    const completedBonus = Math.min(30, (metrics.completed || 0) * 0.3);
    const score = Math.max(0, 70 + ratingBonus + completedBonus - cancelPenalty - latePenalty);
    DRIVER_SCORES.set(driver.id, Math.round(score));
  });
}

function scoreDriver(driver, cook) {
  const distance = haversine(driver, cook);
  const reliability = DRIVER_SCORES.get(driver.id) || 50;
  return reliability - distance * 8;
}

function assignDrivers() {
  const assignments = [];
  const openOrders = orders.filter((o) => o.status !== "delivered");
  openOrders.forEach((order) => {
    const cook = cooks.find((c) => c.id === order.cookId);
    if (!cook) return;
    let best = null;
    let bestScore = -Infinity;
    drivers.forEach((driver) => {
      const score = scoreDriver(driver, cook);
      if (score > bestScore) {
        bestScore = score;
        best = driver;
      }
    });
    if (best) {
      order.driverId = best.id;
      assignments.push({ orderId: order.id, driverId: best.id, score: bestScore });
    }
  });
  return assignments;
}

function estimatePriceCents(cook, customer) {
  const distance = haversine(cook, customer);
  const surge = distance > DENSITY_RADIUS_KM ? SURGE_MULTIPLIER : 1;
  return Math.round((BASE_FEE_CENTS + distance * PER_KM_FEE_CENTS) * surge);
}

function detectAlerts() {
  ALERTS.length = 0;
  drivers.forEach((driver) => {
    const last = DRIVER_LAST_UPDATE.get(driver.id) || 0;
    if (Date.now() - last > DRIVER_STALE_MS * 2) {
      ALERTS.push({ type: "gps_stale", driverId: driver.id, lastUpdate: last });
    }
  });
  orders.forEach((order) => {
    if (order.status === "delivering") {
      const etaSeconds = estimateEtaSeconds(
        drivers.find((d) => d.id === order.driverId),
        cooks.find((c) => c.id === order.cookId),
        customers.find((c) => c.id === order.customerId)
      );
      if (etaSeconds > 1800) {
        ALERTS.push({ type: "eta_high", orderId: order.id, etaSeconds });
      }
    }
  });
}

function decodePolyline(encoded) {
  let index = 0;
  let lat = 0;
  let lng = 0;
  const coordinates = [];

  while (index < encoded.length) {
    let result = 0;
    let shift = 0;
    let byte;
    do {
      byte = encoded.charCodeAt(index++) - 63;
      result |= (byte & 0x1f) << shift;
      shift += 5;
    } while (byte >= 0x20);
    const deltaLat = (result & 1) ? ~(result >> 1) : result >> 1;
    lat += deltaLat;

    result = 0;
    shift = 0;
    do {
      byte = encoded.charCodeAt(index++) - 63;
      result |= (byte & 0x1f) << shift;
      shift += 5;
    } while (byte >= 0x20);
    const deltaLng = (result & 1) ? ~(result >> 1) : result >> 1;
    lng += deltaLng;

    coordinates.push([lat / 1e5, lng / 1e5]);
  }

  return coordinates;
}

function requestJson(urlString, options = {}) {
  const url = new URL(urlString);
  const transport = url.protocol === "https:" ? https : http;

  return new Promise((resolve, reject) => {
    const req = transport.request(
      url,
      {
        method: options.method || "GET",
        headers: options.headers || {},
      },
      (res) => {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          if (res.statusCode && res.statusCode >= 400) {
            return reject(new Error(`HTTP ${res.statusCode}: ${data}`));
          }
          try {
            resolve(JSON.parse(data));
          } catch (err) {
            reject(err);
          }
        });
      }
    );

    req.on("error", reject);
    if (options.body) {
      req.write(options.body);
    }
    req.end();
  });
}

function normalizeCoords(coords) {
  return coords.map((c) => ({ lat: c.lat, lng: c.lng }));
}

async function routeWithMapbox(coords, profile) {
  const token = process.env.MAPBOX_TOKEN;
  if (!token) throw new Error("MAPBOX_TOKEN not set");
  const coordString = coords.map((c) => `${c.lng},${c.lat}`).join(";");
  const url =
    `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coordString}` +
    `?geometries=geojson&overview=full&access_token=${token}`;
  const json = await requestJson(url);
  const route = json.routes && json.routes[0];
  if (!route) throw new Error("Mapbox: no routes");
  return {
    provider: "mapbox",
    distanceMeters: route.distance,
    durationSeconds: route.duration,
    geometry: route.geometry.coordinates.map((c) => [c[1], c[0]]),
  };
}

async function routeWithOsrm(coords, profile) {
  const base = process.env.OSRM_BASE_URL || DEFAULT_OSRM;
  const coordString = coords.map((c) => `${c.lng},${c.lat}`).join(";");
  const url =
    `${base}/route/v1/${profile}/${coordString}` +
    "?geometries=geojson&overview=full";
  const json = await requestJson(url);
  const route = json.routes && json.routes[0];
  if (!route) throw new Error("OSRM: no routes");
  return {
    provider: "osrm",
    distanceMeters: route.distance,
    durationSeconds: route.duration,
    geometry: route.geometry.coordinates.map((c) => [c[1], c[0]]),
  };
}

async function routeWithGoogle(coords) {
  const key = process.env.GOOGLE_MAPS_API_KEY;
  if (!key) throw new Error("GOOGLE_MAPS_API_KEY not set");
  if (coords.length < 2) throw new Error("Google: need at least 2 coordinates");

  const origin = coords[0];
  const destination = coords[coords.length - 1];
  const intermediates = coords.slice(1, -1).map((c) => ({
    location: { latLng: { latitude: c.lat, longitude: c.lng } },
  }));

  const body = JSON.stringify({
    origin: { location: { latLng: { latitude: origin.lat, longitude: origin.lng } } },
    destination: { location: { latLng: { latitude: destination.lat, longitude: destination.lng } } },
    intermediates,
    travelMode: "DRIVE",
    routingPreference: "TRAFFIC_AWARE",
    polylineQuality: "HIGH_QUALITY",
  });

  const json = await requestJson("https://routes.googleapis.com/directions/v2:computeRoutes", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Goog-Api-Key": key,
      "X-Goog-FieldMask": "routes.distanceMeters,routes.duration,routes.polyline.encodedPolyline",
    },
    body,
  });

  const route = json.routes && json.routes[0];
  if (!route || !route.polyline) throw new Error("Google: no routes");

  const decoded = decodePolyline(route.polyline.encodedPolyline);
  return {
    provider: "google",
    distanceMeters: route.distanceMeters,
    durationSeconds: route.duration ? parseInt(route.duration.replace("s", ""), 10) : null,
    geometry: decoded.map((c) => [c[0], c[1]]),
  };
}

async function handleRouteRequest(req, res) {
  let body = "";
  req.on("data", (chunk) => {
    body += chunk;
  });
  req.on("end", async () => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");
    res.setHeader("Content-Type", "application/json");

    let payload;
    try {
      payload = JSON.parse(body);
    } catch (err) {
      res.statusCode = 400;
      res.end(JSON.stringify({ error: "Invalid JSON body" }));
      return;
    }

    const provider = payload.provider || DEFAULT_PROVIDER;
    const profile = payload.profile || "driving";
    const coords = normalizeCoords(payload.coordinates || []);

    if (coords.length < 2) {
      res.statusCode = 400;
      res.end(JSON.stringify({ error: "At least 2 coordinates are required" }));
      return;
    }

    try {
      let route;
      if (provider === "mapbox") {
        route = await routeWithMapbox(coords, profile);
      } else if (provider === "google") {
        route = await routeWithGoogle(coords);
      } else {
        route = await routeWithOsrm(coords, profile);
      }
      res.statusCode = 200;
      res.end(JSON.stringify(route));
    } catch (err) {
      res.statusCode = 500;
      res.end(JSON.stringify({ error: err.message }));
    }
  });
}

function acceptWebSocket(req, socket, head) {
  const key = req.headers["sec-websocket-key"];
  if (!key) {
    socket.destroy();
    return;
  }

  const acceptKey = crypto
    .createHash("sha1")
    .update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
    .digest("base64");

  socket.write(
    [
      "HTTP/1.1 101 Switching Protocols",
      "Upgrade: websocket",
      "Connection: Upgrade",
      `Sec-WebSocket-Accept: ${acceptKey}`,
      "\r\n",
    ].join("\r\n")
  );

  const url = new URL(req.url, "http://localhost");
  const token = url.searchParams.get("token");
  const auth = token ? DEMO_TOKENS.get(token) : null;
  const role = auth?.role || "dispatch";
  const orderId = auth?.orderId || "";
  const driverId = auth?.driverId || "";

  socket.write(encodeFrame(JSON.stringify(makeInitPayload())));

  const interval = setInterval(() => {
    drivers.forEach(jitterLocation);
    const scoped = buildScopedPayload(role, orderId, driverId);
    socket.write(encodeFrame(JSON.stringify(scoped)));
  }, UPDATE_MS);

  socket.on("close", () => clearInterval(interval));
  socket.on("error", () => clearInterval(interval));
}

function encodeFrame(data) {
  const payload = Buffer.from(data);
  const length = payload.length;

  if (length < 126) {
    return Buffer.concat([Buffer.from([0x81, length]), payload]);
  }

  if (length < 65536) {
    const header = Buffer.from([0x81, 126, length >> 8, length & 0xff]);
    return Buffer.concat([header, payload]);
  }

  const header = Buffer.from([0x81, 127, 0, 0, 0, 0, 0, 0, (length >> 8) & 0xff, length & 0xff]);
  return Buffer.concat([header, payload]);
}

function handleLogin(req, res) {
  let body = "";
  req.on("data", (chunk) => {
    body += chunk;
  });
  req.on("end", () => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");
    res.setHeader("Content-Type", "application/json");

    let payload;
    try {
      payload = JSON.parse(body);
    } catch (err) {
      res.statusCode = 400;
      res.end(JSON.stringify({ error: "Invalid JSON body" }));
      return;
    }

    const role = payload.role || "dispatch";
    const orderId = payload.orderId || "";
    const driverId = payload.driverId || "";

    const token = crypto.randomBytes(12).toString("hex");
    DEMO_TOKENS.set(token, { role, orderId, driverId, createdAt: Date.now() });

    res.statusCode = 200;
    res.end(JSON.stringify({ token, role, orderId, driverId }));
  });
}

function handleMe(req, res) {
  const url = new URL(req.url, "http://localhost");
  const token = url.searchParams.get("token");
  const auth = token ? DEMO_TOKENS.get(token) : null;
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Content-Type", "application/json");
  if (!auth) {
    res.statusCode = 401;
    res.end(JSON.stringify({ error: "Invalid token" }));
    return;
  }
  res.statusCode = 200;
  res.end(JSON.stringify(auth));
}

function getAuthFromRequest(req) {
  const url = new URL(req.url, "http://localhost");
  const token = url.searchParams.get("token");
  return token ? DEMO_TOKENS.get(token) : null;
}

function handleLocationUpdate(req, res) {
  let body = "";
  req.on("data", (chunk) => {
    body += chunk;
  });
  req.on("end", () => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");
    res.setHeader("Content-Type", "application/json");

    const auth = getAuthFromRequest(req);
    if (!auth || (auth.role !== "driver" && auth.role !== "dispatch")) {
      res.statusCode = 401;
      res.end(JSON.stringify({ error: "Unauthorized" }));
      return;
    }

    let payload;
    try {
      payload = JSON.parse(body);
    } catch (err) {
      res.statusCode = 400;
      res.end(JSON.stringify({ error: "Invalid JSON body" }));
      return;
    }

    const driverId = payload.driverId || auth.driverId;
    if (!driverId) {
      res.statusCode = 400;
      res.end(JSON.stringify({ error: "driverId required" }));
      return;
    }

    if (auth.role === "driver" && auth.driverId && auth.driverId !== driverId) {
      res.statusCode = 403;
      res.end(JSON.stringify({ error: "driverId mismatch" }));
      return;
    }

    const lat = Number(payload.lat);
    const lng = Number(payload.lng);
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      res.statusCode = 400;
      res.end(JSON.stringify({ error: "lat/lng required" }));
      return;
    }

    const driver = drivers.find((d) => d.id === driverId);
    if (!driver) {
      res.statusCode = 404;
      res.end(JSON.stringify({ error: "driver not found" }));
      return;
    }

    driver.lat = lat;
    driver.lng = lng;
    DRIVER_LAST_UPDATE.set(driverId, Date.now());

    res.statusCode = 200;
    res.end(JSON.stringify({ ok: true, driverId, lat, lng }));
  });
}

function handleLatestLocations(req, res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Content-Type", "application/json");
  res.statusCode = 200;
  res.end(
    JSON.stringify({
      drivers: drivers.map((d) => ({
        id: d.id,
        lat: d.lat,
        lng: d.lng,
        updatedAt: DRIVER_LAST_UPDATE.get(d.id) || null,
      })),
    })
  );
}

function handleOrderStatusUpdate(req, res) {
  let body = "";
  req.on("data", (chunk) => {
    body += chunk;
  });
  req.on("end", () => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");
    res.setHeader("Content-Type", "application/json");

    const auth = getAuthFromRequest(req);
    if (!auth || (auth.role !== "cook" && auth.role !== "driver" && auth.role !== "dispatch")) {
      res.statusCode = 401;
      res.end(JSON.stringify({ error: "Unauthorized" }));
      return;
    }

    let payload;
    try {
      payload = JSON.parse(body);
    } catch (err) {
      res.statusCode = 400;
      res.end(JSON.stringify({ error: "Invalid JSON body" }));
      return;
    }

    const orderId = payload.orderId;
    const status = payload.status;
    if (!orderId || !status) {
      res.statusCode = 400;
      res.end(JSON.stringify({ error: "orderId and status required" }));
      return;
    }

    const order = orders.find((o) => o.id === orderId);
    if (!order) {
      res.statusCode = 404;
      res.end(JSON.stringify({ error: "order not found" }));
      return;
    }

    order.status = status;
    res.statusCode = 200;
    res.end(JSON.stringify({ ok: true, orderId, status }));
  });
}

function handleEtaRequest(req, res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Content-Type", "application/json");
  const url = new URL(req.url, "http://localhost");
  const orderId = url.searchParams.get("orderId");
  if (!orderId) {
    res.statusCode = 400;
    res.end(JSON.stringify({ error: "orderId required" }));
    return;
  }
  const order = orders.find((o) => o.id === orderId);
  if (!order) {
    res.statusCode = 404;
    res.end(JSON.stringify({ error: "order not found" }));
    return;
  }
  const driver = drivers.find((d) => d.id === order.driverId);
  const cook = cooks.find((c) => c.id === order.cookId);
  const customer = customers.find((c) => c.id === order.customerId);
  if (!driver || !cook || !customer) {
    res.statusCode = 404;
    res.end(JSON.stringify({ error: "missing entities" }));
    return;
  }

  const etaSeconds = estimateEtaSeconds(driver, cook, customer);
  res.statusCode = 200;
  res.end(JSON.stringify({ orderId, etaSeconds }));
}

function estimateEtaSeconds(driver, cook, customer) {
  const distToCook = haversine(driver, cook);
  const distToCustomer = haversine(cook, customer);
  const avgSpeedKmh = 35;
  const travelSeconds = ((distToCook + distToCustomer) / avgSpeedKmh) * 3600;
  return Math.max(60, Math.round(travelSeconds));
}

function haversine(a, b) {
  const toRad = (v) => (v * Math.PI) / 180;
  const R = 6371;
  const dLat = toRad(b.lat - a.lat);
  const dLng = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat);
  const lat2 = toRad(b.lat);
  const h =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) ** 2;
  return 2 * R * Math.asin(Math.sqrt(h));
}

const server = http.createServer((_, res) => {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");
  res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS, GET");
  if (_.method === "OPTIONS") {
    res.writeHead(204, {
      "Access-Control-Allow-Headers": "Content-Type",
      "Access-Control-Allow-Methods": "POST, OPTIONS, GET",
    });
    res.end();
    return;
  }

  if (_.method === "GET" && _.url === "/api/config") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify({
        name: ROUTING_SERVER_NAME,
        defaultProvider: DEFAULT_PROVIDER,
        osrmBaseUrl: process.env.OSRM_BASE_URL || DEFAULT_OSRM,
        mapboxEnabled: Boolean(process.env.MAPBOX_TOKEN),
        googleEnabled: Boolean(process.env.GOOGLE_MAPS_API_KEY),
      })
    );
    return;
  }

  if (_.method === "POST" && _.url === "/api/auth/login") {
    handleLogin(_, res);
    return;
  }

  if (_.method === "GET" && _.url.startsWith("/api/me")) {
    handleMe(_, res);
    return;
  }

  if (_.method === "POST" && _.url.startsWith("/api/location")) {
    handleLocationUpdate(_, res);
    return;
  }

  if (_.method === "GET" && _.url === "/api/locations/latest") {
    handleLatestLocations(_, res);
    return;
  }

  if (_.method === "POST" && _.url.startsWith("/api/orders/status")) {
    handleOrderStatusUpdate(_, res);
    return;
  }

  if (_.method === "GET" && _.url.startsWith("/api/orders/eta")) {
    handleEtaRequest(_, res);
    return;
  }

  if (_.method === "GET" && _.url.startsWith("/api/dispatch/batches")) {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Content-Type", "application/json");
    res.statusCode = 200;
    res.end(JSON.stringify({ batches: buildBatches() }));
    return;
  }

  if (_.method === "POST" && _.url.startsWith("/api/dispatch/assign")) {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Content-Type", "application/json");
    refreshDriverScores();
    const assignments = assignDrivers();
    res.statusCode = 200;
    res.end(JSON.stringify({ assignments }));
    return;
  }

  if (_.method === "GET" && _.url.startsWith("/api/drivers/scores")) {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Content-Type", "application/json");
    refreshDriverScores();
    res.statusCode = 200;
    res.end(JSON.stringify({ scores: Object.fromEntries(DRIVER_SCORES) }));
    return;
  }

  if (_.method === "GET" && _.url.startsWith("/api/pricing/quote")) {
    const url = new URL(_.url, "http://localhost");
    const cookId = url.searchParams.get("cookId");
    const customerId = url.searchParams.get("customerId");
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Content-Type", "application/json");
    if (!cookId || !customerId) {
      res.statusCode = 400;
      res.end(JSON.stringify({ error: "cookId and customerId required" }));
      return;
    }
    const cook = cooks.find((c) => c.id === cookId);
    const customer = customers.find((c) => c.id === customerId);
    if (!cook || !customer) {
      res.statusCode = 404;
      res.end(JSON.stringify({ error: "not found" }));
      return;
    }
    const priceCents = estimatePriceCents(cook, customer);
    res.statusCode = 200;
    res.end(JSON.stringify({ cookId, customerId, priceCents }));
    return;
  }

  if (_.method === "GET" && _.url.startsWith("/api/alerts")) {
    detectAlerts();
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Content-Type", "application/json");
    res.statusCode = 200;
    res.end(JSON.stringify({ alerts: ALERTS }));
    return;
  }

  if (_.method === "POST" && _.url === "/api/route") {
    handleRouteRequest(_, res);
    return;
  }

  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("RideNDine live GPS demo server\n");
});

server.on("upgrade", (req, socket, head) => {
  acceptWebSocket(req, socket, head);
});

server.listen(PORT, () => {
  console.log(`Live GPS demo server running on ws://localhost:${PORT}`);
  console.log(`Routing proxy available at http://localhost:${PORT}/api/route`);
});
