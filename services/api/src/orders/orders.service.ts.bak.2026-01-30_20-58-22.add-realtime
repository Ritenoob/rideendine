import {
  Injectable,
  Inject,
  NotFoundException,
  BadRequestException,
  ForbiddenException,
  Logger,
} from '@nestjs/common';
import { Pool } from 'pg';
import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
import { CreateOrderDto, RejectOrderDto, RefundOrderDto, OrderQueryDto } from './dto/order.dto';
import { OrderStatus, OrderStateMachine } from './order-state-machine';
import { CommissionCalculator } from './commission-calculator';
import { StripeService } from '../stripe/stripe.service';

@Injectable()
export class OrdersService {
  private readonly logger = new Logger(OrdersService.name);

  constructor(
    @Inject('DATABASE_POOL') private db: Pool,
    private readonly stripeService: StripeService,
  ) {}

  async createOrder(customerId: string, createDto: CreateOrderDto) {
    const client = await this.db.connect();

    try {
      await client.query('BEGIN');

      // 1. Validate chef exists and is active
      const chefResult = await client.query(
        `SELECT id, business_name, is_active, verification_status, 
                minimum_order_cents, stripe_account_id, stripe_onboarding_complete
         FROM chefs
         WHERE id = $1`,
        [createDto.chefId]
      );

      if (chefResult.rows.length === 0) {
        throw new NotFoundException('Chef not found');
      }

      const chef = chefResult.rows[0];

      if (!chef.is_active) {
        throw new BadRequestException('Chef is not currently accepting orders');
      }

      if (chef.verification_status !== 'approved') {
        throw new BadRequestException('Chef is not verified');
      }

      if (!chef.stripe_onboarding_complete) {
        throw new BadRequestException('Chef has not completed payment setup');
      }

      // 2. Validate and fetch menu items
      const itemIds = createDto.items.map(item => item.menuItemId);
      const itemsResult = await client.query(
        `SELECT mi.id, mi.name, mi.price_cents, mi.is_available, mi.prep_time_minutes,
                m.chef_id, m.is_active as menu_active
         FROM menu_items mi
         JOIN menus m ON mi.menu_id = m.id
         WHERE mi.id = ANY($1::uuid[])`,
        [itemIds]
      );

      if (itemsResult.rows.length !== itemIds.length) {
        throw new BadRequestException('One or more menu items not found');
      }

      // Validate all items belong to the same chef
      const invalidItems = itemsResult.rows.filter(
        item => item.chef_id !== createDto.chefId || !item.is_available || !item.menu_active
      );

      if (invalidItems.length > 0) {
        throw new BadRequestException('Some menu items are not available');
      }

      // 3. Calculate subtotal
      let subtotalCents = 0;
      const orderItems: any[] = [];

      for (const dtoItem of createDto.items) {
        const menuItem = itemsResult.rows.find(mi => mi.id === dtoItem.menuItemId);
        const itemTotalCents = menuItem.price_cents * dtoItem.quantity;
        subtotalCents += itemTotalCents;

        orderItems.push({
          menuItemId: menuItem.id,
          menuItemName: menuItem.name,
          quantity: dtoItem.quantity,
          priceCents: menuItem.price_cents,
          totalCents: itemTotalCents,
          notes: dtoItem.notes,
        });
      }

      // 4. Check minimum order amount
      if (subtotalCents < chef.minimum_order_cents) {
        throw new BadRequestException(
          `Order total $${(subtotalCents / 100).toFixed(2)} is below minimum ` +
          `$${(chef.minimum_order_cents / 100).toFixed(2)}`
        );
      }

      // 5. Calculate totals using CommissionCalculator
      const breakdown = CommissionCalculator.calculate(subtotalCents);

      // 6. Generate unique order number
      const orderNumber = await this.generateOrderNumber(client);

      // 7. Create order
      const orderResult = await client.query(
        `INSERT INTO orders (
          customer_id, chef_id, order_number, status,
          delivery_address, delivery_latitude, delivery_longitude,
          delivery_instructions, scheduled_delivery_time,
          subtotal_cents, tax_cents, delivery_fee_cents,
          platform_fee_cents, total_cents
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
        RETURNING *`,
        [
          customerId,
          createDto.chefId,
          orderNumber,
          OrderStatus.PENDING,
          createDto.deliveryAddress,
          createDto.deliveryLatitude,
          createDto.deliveryLongitude,
          createDto.deliveryInstructions || null,
          createDto.scheduledDeliveryTime || null,
          breakdown.subtotalCents,
          breakdown.taxCents,
          breakdown.deliveryFeeCents,
          breakdown.platformFeeCents,
          breakdown.totalCents,
        ]
      );

      const order = orderResult.rows[0];

      // 8. Insert order items
      for (const item of orderItems) {
        await client.query(
          `INSERT INTO order_items (
            order_id, menu_item_id, menu_item_name,
            quantity, price_cents, total_cents, notes
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7)`,
          [
            order.id,
            item.menuItemId,
            item.menuItemName,
            item.quantity,
            item.priceCents,
            item.totalCents,
            item.notes,
          ]
        );
      }

      // 9. Create initial status history entry
      await client.query(
        `INSERT INTO order_status_history (
          order_id, status, created_by
        )
        VALUES ($1, $2, $3)`,
        [order.id, OrderStatus.PENDING, customerId]
      );

      await client.query('COMMIT');

      this.logger.log(`Order created: ${order.order_number} (${order.id})`);

      // Return order with items
      return {
        id: order.id,
        orderNumber: order.order_number,
        chefId: order.chef_id,
        chefName: chef.business_name,
        status: order.status,
        deliveryAddress: order.delivery_address,
        scheduledDeliveryTime: order.scheduled_delivery_time,
        subtotalCents: order.subtotal_cents,
        taxCents: order.tax_cents,
        deliveryFeeCents: order.delivery_fee_cents,
        platformFeeCents: order.platform_fee_cents,
        totalCents: order.total_cents,
        items: orderItems,
        createdAt: order.created_at,
      };

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  private async generateOrderNumber(client: Pool | any): Promise<string> {
    // Format: RND-YYYYMMDD-####
    const date = new Date();
    const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
    
    // Get count of orders created today
    const countResult = await client.query(
      `SELECT COUNT(*) as count
       FROM orders
       WHERE DATE(created_at) = CURRENT_DATE`
    );

    const todayCount = parseInt(countResult.rows[0].count) + 1;
    const sequence = todayCount.toString().padStart(4, '0');

    return `RND-${dateStr}-${sequence}`;
  }

  async getOrderById(orderId: string, userId: string, userRole: string) {
    const result = await this.db.query(
      `SELECT o.*,
              c.business_name as chef_name,
              u.full_name as customer_name, u.email as customer_email,
              u.phone_number as customer_phone,
              d.full_name as driver_name
       FROM orders o
       JOIN chefs c ON o.chef_id = c.id
       JOIN users u ON o.customer_id = u.id
       LEFT JOIN users d ON o.driver_id = d.id
       WHERE o.id = $1`,
      [orderId]
    );

    if (result.rows.length === 0) {
      throw new NotFoundException('Order not found');
    }

    const order = result.rows[0];

    // Authorization check
    const canView =
      userRole === 'admin' ||
      order.customer_id === userId ||
      (await this.userOwnsChef(userId, order.chef_id)) ||
      order.driver_id === userId;

    if (!canView) {
      throw new ForbiddenException('You do not have permission to view this order');
    }

    // Get order items
    const itemsResult = await this.db.query(
      'SELECT * FROM order_items WHERE order_id = $1',
      [orderId]
    );

    return {
      id: order.id,
      orderNumber: order.order_number,
      status: order.status,
      chefId: order.chef_id,
      chefName: order.chef_name,
      customerId: order.customer_id,
      customerName: order.customer_name,
      customerEmail: order.customer_email,
      customerPhone: order.customer_phone,
      driverId: order.driver_id,
      driverName: order.driver_name,
      deliveryAddress: order.delivery_address,
      deliveryInstructions: order.delivery_instructions,
      scheduledDeliveryTime: order.scheduled_delivery_time,
      subtotalCents: order.subtotal_cents,
      taxCents: order.tax_cents,
      deliveryFeeCents: order.delivery_fee_cents,
      platformFeeCents: order.platform_fee_cents,
      totalCents: order.total_cents,
      items: itemsResult.rows.map(item => ({
        id: item.id,
        menuItemName: item.menu_item_name,
        quantity: item.quantity,
        priceCents: item.price_cents,
        totalCents: item.total_cents,
        notes: item.notes,
      })),
      createdAt: order.created_at,
      acceptedAt: order.accepted_at,
      readyAt: order.ready_at,
      pickedUpAt: order.picked_up_at,
      deliveredAt: order.delivered_at,
    };
  }

  private async userOwnsChef(userId: string, chefId: string): Promise<boolean> {
    const result = await this.db.query(
      'SELECT id FROM chefs WHERE id = $1 AND user_id = $2',
      [chefId, userId]
    );
    return result.rows.length > 0;
  }

  /**
   * List orders with filters and pagination
   */
  async listOrders(query: OrderQueryDto, userId: string, userRole: string) {
    const page = parseInt(query.page || '1');
    const perPage = Math.min(parseInt(query.perPage || '20'), 100);
    const offset = (page - 1) * perPage;

    // Build WHERE clause based on role and filters
    const conditions: string[] = [];
    const params: any[] = [];
    let paramIndex = 1;

    // Role-based filtering
    if (userRole === 'customer') {
      conditions.push(`o.customer_id = $${paramIndex++}`);
      params.push(userId);
    } else if (userRole === 'chef') {
      // Get chef ID for this user
      const chefResult = await this.db.query(
        'SELECT id FROM chefs WHERE user_id = $1',
        [userId],
      );
      if (chefResult.rows.length === 0) {
        return { orders: [], total: 0, page, perPage };
      }
      conditions.push(`o.chef_id = $${paramIndex++}`);
      params.push(chefResult.rows[0].id);
    } else if (userRole === 'driver') {
      conditions.push(`o.driver_id = $${paramIndex++}`);
      params.push(userId);
    }
    // Admin can see all orders

    // Additional filters
    if (query.status) {
      conditions.push(`o.status = $${paramIndex++}`);
      params.push(query.status);
    }

    if (query.chefId && userRole === 'admin') {
      conditions.push(`o.chef_id = $${paramIndex++}`);
      params.push(query.chefId);
    }

    if (query.customerId && userRole === 'admin') {
      conditions.push(`o.customer_id = $${paramIndex++}`);
      params.push(query.customerId);
    }

    if (query.dateFrom) {
      conditions.push(`o.created_at >= $${paramIndex++}`);
      params.push(query.dateFrom);
    }

    if (query.dateTo) {
      conditions.push(`o.created_at <= $${paramIndex++}`);
      params.push(query.dateTo);
    }

    const whereClause =
      conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    // Get total count
    const countResult = await this.db.query(
      `SELECT COUNT(*) as total FROM orders o ${whereClause}`,
      params,
    );
    const total = parseInt(countResult.rows[0].total);

    // Get orders
    const ordersResult = await this.db.query(
      `SELECT o.*, c.business_name as chef_name
       FROM orders o
       JOIN chefs c ON o.chef_id = c.id
       ${whereClause}
       ORDER BY o.created_at DESC
       LIMIT $${paramIndex++} OFFSET $${paramIndex}`,
      [...params, perPage, offset],
    );

    return {
      orders: ordersResult.rows.map((order) => ({
        id: order.id,
        orderNumber: order.order_number,
        status: order.status,
        chefId: order.chef_id,
        chefName: order.chef_name,
        totalCents: order.total_cents,
        createdAt: order.created_at,
      })),
      total,
      page,
      perPage,
      totalPages: Math.ceil(total / perPage),
    };
  }

  /**
   * Create a PaymentIntent for an order
   */
  async createPaymentIntent(orderId: string, userId: string) {
    // Get order details
    const orderResult = await this.db.query(
      `SELECT o.*, c.stripe_account_id, c.business_name
       FROM orders o
       JOIN chefs c ON o.chef_id = c.id
       WHERE o.id = $1`,
      [orderId],
    );

    if (orderResult.rows.length === 0) {
      throw new NotFoundException('Order not found');
    }

    const order = orderResult.rows[0];

    // Verify ownership
    if (order.customer_id !== userId) {
      throw new ForbiddenException('You do not own this order');
    }

    // Verify order is in correct state
    if (order.status !== OrderStatus.PENDING) {
      throw new BadRequestException(
        `Cannot create payment for order in status: ${order.status}`,
      );
    }

    // Check for existing payment
    const existingPayment = await this.db.query(
      `SELECT * FROM payments WHERE order_id = $1 AND status IN ('pending', 'processing')`,
      [orderId],
    );

    if (existingPayment.rows.length > 0) {
      const payment = existingPayment.rows[0];
      // Return existing PaymentIntent
      const paymentIntent = await this.stripeService.retrievePaymentIntent(
        payment.stripe_payment_intent_id,
      );
      return {
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
        amountCents: order.total_cents,
      };
    }

    // Get customer's Stripe customer ID
    const customerResult = await this.db.query(
      `SELECT c.stripe_customer_id, u.email, up.first_name, up.last_name
       FROM customers c
       JOIN users u ON c.user_id = u.id
       LEFT JOIN user_profiles up ON u.id = up.user_id
       WHERE c.user_id = $1`,
      [userId],
    );

    let stripeCustomerId: string | undefined;

    if (customerResult.rows.length > 0) {
      const customer = customerResult.rows[0];
      if (customer.stripe_customer_id) {
        stripeCustomerId = customer.stripe_customer_id;
      } else {
        // Create Stripe customer
        const stripeCustomer = await this.stripeService.createOrRetrieveCustomer({
          email: customer.email,
          name: `${customer.first_name || ''} ${customer.last_name || ''}`.trim() || undefined,
        });
        stripeCustomerId = stripeCustomer.id;

        // Save Stripe customer ID
        await this.db.query(
          'UPDATE customers SET stripe_customer_id = $1 WHERE user_id = $2',
          [stripeCustomerId, userId],
        );
      }
    }

    // Calculate platform fee (to keep on platform)
    const platformFeeCents = order.platform_fee_cents + order.tax_cents;

    // Create PaymentIntent
    const paymentIntent = await this.stripeService.createPaymentIntent({
      amountCents: order.total_cents,
      customerId: stripeCustomerId,
      chefStripeAccountId: order.stripe_account_id,
      orderId: order.id,
      orderNumber: order.order_number,
      applicationFeeCents: platformFeeCents,
    });

    // Save payment record
    await this.db.query(
      `INSERT INTO payments (order_id, stripe_payment_intent_id, amount_cents, status)
       VALUES ($1, $2, $3, $4)`,
      [orderId, paymentIntent.id, order.total_cents, 'pending'],
    );

    this.logger.log(
      `Created PaymentIntent ${paymentIntent.id} for order ${order.order_number}`,
    );

    return {
      clientSecret: paymentIntent.client_secret,
      paymentIntentId: paymentIntent.id,
      amountCents: order.total_cents,
    };
  }

  /**
   * Chef accepts an order
   */
  async acceptOrder(orderId: string, userId: string) {
    const client = await this.db.connect();

    try {
      await client.query('BEGIN');

      // Get order with chef info
      const orderResult = await client.query(
        `SELECT o.*, c.user_id as chef_user_id
         FROM orders o
         JOIN chefs c ON o.chef_id = c.id
         WHERE o.id = $1
         FOR UPDATE`,
        [orderId],
      );

      if (orderResult.rows.length === 0) {
        throw new NotFoundException('Order not found');
      }

      const order = orderResult.rows[0];

      // Verify chef owns this order
      if (order.chef_user_id !== userId) {
        throw new ForbiddenException('You do not own this order');
      }

      // Validate state transition
      const currentStatus = order.status as OrderStatus;
      const newStatus = OrderStatus.ACCEPTED;

      OrderStateMachine.validateTransition(currentStatus, newStatus);

      // Update order status
      await client.query(
        `UPDATE orders
         SET status = $1, accepted_at = NOW()
         WHERE id = $2`,
        [newStatus, orderId],
      );

      // Add status history
      await client.query(
        `INSERT INTO order_status_history (order_id, status, created_by)
         VALUES ($1, $2, $3)`,
        [orderId, newStatus, userId],
      );

      await client.query('COMMIT');

      this.logger.log(`Order ${order.order_number} accepted by chef`);

      return {
        id: order.id,
        orderNumber: order.order_number,
        status: newStatus,
        message: 'Order accepted successfully',
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Chef rejects an order
   */
  async rejectOrder(orderId: string, userId: string, rejectDto: RejectOrderDto) {
    const client = await this.db.connect();

    try {
      await client.query('BEGIN');

      // Get order with chef info
      const orderResult = await client.query(
        `SELECT o.*, c.user_id as chef_user_id
         FROM orders o
         JOIN chefs c ON o.chef_id = c.id
         WHERE o.id = $1
         FOR UPDATE`,
        [orderId],
      );

      if (orderResult.rows.length === 0) {
        throw new NotFoundException('Order not found');
      }

      const order = orderResult.rows[0];

      // Verify chef owns this order
      if (order.chef_user_id !== userId) {
        throw new ForbiddenException('You do not own this order');
      }

      // Validate state transition
      const currentStatus = order.status as OrderStatus;
      const newStatus = OrderStatus.REJECTED;

      OrderStateMachine.validateTransition(currentStatus, newStatus);

      // Update order status
      await client.query(
        `UPDATE orders
         SET status = $1, rejection_reason = $2
         WHERE id = $3`,
        [newStatus, rejectDto.rejectionReason, orderId],
      );

      // Add status history
      await client.query(
        `INSERT INTO order_status_history (order_id, status, notes, created_by)
         VALUES ($1, $2, $3, $4)`,
        [orderId, newStatus, rejectDto.rejectionReason, userId],
      );

      await client.query('COMMIT');

      this.logger.log(
        `Order ${order.order_number} rejected: ${rejectDto.rejectionReason}`,
      );

      // Initiate refund if payment was made
      if (OrderStateMachine.requiresRefund(currentStatus)) {
        await this.initiateRefund(orderId, 'Order rejected by chef');
      }

      return {
        id: order.id,
        orderNumber: order.order_number,
        status: newStatus,
        message: 'Order rejected',
        rejectionReason: rejectDto.rejectionReason,
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Chef marks order as ready for pickup
   */
  async markOrderReady(orderId: string, userId: string) {
    const client = await this.db.connect();

    try {
      await client.query('BEGIN');

      // Get order with chef info
      const orderResult = await client.query(
        `SELECT o.*, c.user_id as chef_user_id
         FROM orders o
         JOIN chefs c ON o.chef_id = c.id
         WHERE o.id = $1
         FOR UPDATE`,
        [orderId],
      );

      if (orderResult.rows.length === 0) {
        throw new NotFoundException('Order not found');
      }

      const order = orderResult.rows[0];

      // Verify chef owns this order
      if (order.chef_user_id !== userId) {
        throw new ForbiddenException('You do not own this order');
      }

      // Validate state transition (can go from ACCEPTED or PREPARING to READY_FOR_PICKUP)
      const currentStatus = order.status as OrderStatus;
      const newStatus = OrderStatus.READY_FOR_PICKUP;

      OrderStateMachine.validateTransition(currentStatus, newStatus);

      // Update order status
      await client.query(
        `UPDATE orders
         SET status = $1, ready_at = NOW()
         WHERE id = $2`,
        [newStatus, orderId],
      );

      // Add status history
      await client.query(
        `INSERT INTO order_status_history (order_id, status, created_by)
         VALUES ($1, $2, $3)`,
        [orderId, newStatus, userId],
      );

      await client.query('COMMIT');

      this.logger.log(`Order ${order.order_number} marked ready for pickup`);

      return {
        id: order.id,
        orderNumber: order.order_number,
        status: newStatus,
        message: 'Order is ready for pickup',
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Cancel an order
   */
  async cancelOrder(orderId: string, userId: string, reason?: string) {
    const client = await this.db.connect();

    try {
      await client.query('BEGIN');

      // Get order
      const orderResult = await client.query(
        `SELECT o.*, c.user_id as chef_user_id
         FROM orders o
         JOIN chefs c ON o.chef_id = c.id
         WHERE o.id = $1
         FOR UPDATE`,
        [orderId],
      );

      if (orderResult.rows.length === 0) {
        throw new NotFoundException('Order not found');
      }

      const order = orderResult.rows[0];

      // Authorization check (customer, chef, or admin can cancel)
      const isCustomer = order.customer_id === userId;
      const isChef = order.chef_user_id === userId;

      if (!isCustomer && !isChef) {
        throw new ForbiddenException('You cannot cancel this order');
      }

      // Validate state transition
      const currentStatus = order.status as OrderStatus;
      const newStatus = OrderStatus.CANCELLED;

      OrderStateMachine.validateTransition(currentStatus, newStatus);

      // Update order status
      await client.query(
        `UPDATE orders
         SET status = $1, cancellation_reason = $2, cancelled_at = NOW()
         WHERE id = $3`,
        [newStatus, reason || 'Cancelled by user', orderId],
      );

      // Add status history
      await client.query(
        `INSERT INTO order_status_history (order_id, status, notes, created_by)
         VALUES ($1, $2, $3, $4)`,
        [orderId, newStatus, reason || 'Cancelled by user', userId],
      );

      await client.query('COMMIT');

      this.logger.log(`Order ${order.order_number} cancelled`);

      // Initiate refund if payment was made
      if (OrderStateMachine.requiresRefund(currentStatus)) {
        await this.initiateRefund(orderId, reason || 'Order cancelled');
      }

      return {
        id: order.id,
        orderNumber: order.order_number,
        status: newStatus,
        message: 'Order cancelled successfully',
        refundInitiated: OrderStateMachine.requiresRefund(currentStatus),
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Refund an order (admin or chef)
   */
  async refundOrder(orderId: string, userId: string, refundDto: RefundOrderDto) {
    const client = await this.db.connect();

    try {
      await client.query('BEGIN');

      // Get order
      const orderResult = await client.query(
        `SELECT o.*, c.user_id as chef_user_id
         FROM orders o
         JOIN chefs c ON o.chef_id = c.id
         WHERE o.id = $1
         FOR UPDATE`,
        [orderId],
      );

      if (orderResult.rows.length === 0) {
        throw new NotFoundException('Order not found');
      }

      const order = orderResult.rows[0];

      // Get payment
      const paymentResult = await client.query(
        `SELECT * FROM payments WHERE order_id = $1 AND status = 'succeeded'`,
        [orderId],
      );

      if (paymentResult.rows.length === 0) {
        throw new BadRequestException('No successful payment found for this order');
      }

      const payment = paymentResult.rows[0];

      // Determine refund amount
      const refundAmountCents = refundDto.amountCents || order.total_cents;

      if (refundAmountCents > order.total_cents) {
        throw new BadRequestException('Refund amount exceeds order total');
      }

      // Create refund in Stripe
      const refund = await this.stripeService.createRefund({
        paymentIntentId: payment.stripe_payment_intent_id,
        amountCents: refundAmountCents,
        reason: 'requested_by_customer',
      });

      // Update payment status
      await client.query(
        `UPDATE payments SET status = $1, refund_amount_cents = $2 WHERE id = $3`,
        [
          refundAmountCents === order.total_cents ? 'refunded' : 'partially_refunded',
          refundAmountCents,
          payment.id,
        ],
      );

      // Update order status if full refund
      if (refundAmountCents === order.total_cents) {
        await client.query(
          `UPDATE orders SET status = $1 WHERE id = $2`,
          [OrderStatus.REFUNDED, orderId],
        );

        // Add status history
        await client.query(
          `INSERT INTO order_status_history (order_id, status, notes, created_by)
           VALUES ($1, $2, $3, $4)`,
          [orderId, OrderStatus.REFUNDED, refundDto.reason, userId],
        );
      }

      await client.query('COMMIT');

      this.logger.log(
        `Refund ${refund.id} created for order ${order.order_number}: ${CommissionCalculator.formatCents(refundAmountCents)}`,
      );

      return {
        id: order.id,
        orderNumber: order.order_number,
        refundId: refund.id,
        refundAmountCents,
        message: 'Refund processed successfully',
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Internal helper to initiate a refund
   */
  private async initiateRefund(orderId: string, reason: string): Promise<void> {
    try {
      const paymentResult = await this.db.query(
        `SELECT * FROM payments WHERE order_id = $1 AND status = 'succeeded'`,
        [orderId],
      );

      if (paymentResult.rows.length === 0) {
        this.logger.warn(`No payment found to refund for order ${orderId}`);
        return;
      }

      const payment = paymentResult.rows[0];

      const refund = await this.stripeService.createRefund({
        paymentIntentId: payment.stripe_payment_intent_id,
        reason: 'requested_by_customer',
      });

      await this.db.query(
        `UPDATE payments SET status = 'refunded', refund_amount_cents = amount_cents WHERE id = $1`,
        [payment.id],
      );

      await this.db.query(
        `UPDATE orders SET status = $1 WHERE id = $2`,
        [OrderStatus.REFUNDED, orderId],
      );

      this.logger.log(`Auto-refund ${refund.id} processed for order ${orderId}: ${reason}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`Failed to auto-refund order ${orderId}: ${errorMessage}`);
    }
  }

  /**
   * Handle payment confirmation webhook
   */
  async handlePaymentConfirmed(orderId: string, paymentIntentId: string) {
    const client = await this.db.connect();

    try {
      await client.query('BEGIN');

      // Update payment status
      await client.query(
        `UPDATE payments SET status = 'succeeded' WHERE stripe_payment_intent_id = $1`,
        [paymentIntentId],
      );

      // Update order status
      await client.query(
        `UPDATE orders SET status = $1 WHERE id = $2`,
        [OrderStatus.PAYMENT_CONFIRMED, orderId],
      );

      // Add status history
      await client.query(
        `INSERT INTO order_status_history (order_id, status, notes)
         VALUES ($1, $2, $3)`,
        [orderId, OrderStatus.PAYMENT_CONFIRMED, 'Payment confirmed via Stripe webhook'],
      );

      // Get order details for ledger entry
      const orderResult = await client.query(
        `SELECT * FROM orders WHERE id = $1`,
        [orderId],
      );

      if (orderResult.rows.length > 0) {
        const order = orderResult.rows[0];

        // Calculate chef earnings and create ledger entry
        const chefEarnings = CommissionCalculator.calculateChefLedgerEntry(
          order.subtotal_cents,
        );

        await client.query(
          `INSERT INTO chef_ledger (chef_id, order_id, earning_cents, available_for_payout)
           VALUES ($1, $2, $3, $4)`,
          [order.chef_id, orderId, chefEarnings.amountCents, false],
        );
      }

      await client.query('COMMIT');

      this.logger.log(`Payment confirmed for order ${orderId}`);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async getOrderEta(orderId: string, userId: string, userRole: string) {
    const orderResult = await this.db.query(
      `SELECT o.id, o.status, o.customer_id, o.chef_id, o.driver_id,
              o.delivery_latitude, o.delivery_longitude,
              c.latitude as chef_latitude, c.longitude as chef_longitude
       FROM orders o
       JOIN chefs c ON o.chef_id = c.id
       WHERE o.id = $1`,
      [orderId],
    );

    if (orderResult.rows.length === 0) {
      throw new NotFoundException('Order not found');
    }

    const order = orderResult.rows[0];
    const canView =
      userRole === 'admin' ||
      order.customer_id === userId ||
      (await this.userOwnsChef(userId, order.chef_id)) ||
      order.driver_id === userId;

    if (!canView) {
      throw new ForbiddenException('You do not have permission to view this order');
    }

    const destinationLat = this.parseCoordinate(order.delivery_latitude);
    const destinationLng = this.parseCoordinate(order.delivery_longitude);
    if (destinationLat === null || destinationLng === null) {
      throw new BadRequestException('Order missing delivery coordinates');
    }

    let startLat = this.parseCoordinate(order.chef_latitude);
    let startLng = this.parseCoordinate(order.chef_longitude);

    const status = order.status as OrderStatus;
    if (
      [
        OrderStatus.ASSIGNED_TO_DRIVER,
        OrderStatus.PICKED_UP,
        OrderStatus.IN_TRANSIT,
      ].includes(status) &&
      order.driver_id
    ) {
      const driverLocResult = await this.db.query(
        `SELECT current_latitude, current_longitude
         FROM drivers
         WHERE user_id = $1`,
        [order.driver_id],
      );

      if (driverLocResult.rows.length > 0) {
        const driverRow = driverLocResult.rows[0];
        const driverLat = this.parseCoordinate(driverRow.current_latitude);
        const driverLng = this.parseCoordinate(driverRow.current_longitude);
        if (driverLat !== null && driverLng !== null) {
          startLat = driverLat;
          startLng = driverLng;
        }
      }
    }

    if (startLat === null || startLng === null) {
      throw new BadRequestException('Order missing pickup coordinates');
    }

    let route: { provider: string; distanceMeters: number; durationSeconds: number };
    try {
      route = await this.requestRoute([
        { lat: startLat, lng: startLng },
        { lat: destinationLat, lng: destinationLng },
      ]);
    } catch (error) {
      const distanceKm = this.calculateDistanceKm(
        startLat,
        startLng,
        destinationLat,
        destinationLng,
      );
      const durationSeconds = this.estimateDurationSeconds(distanceKm);
      const errorMessage = error instanceof Error ? error.message : 'Unknown routing error';

      this.logger.warn(`Routing service failed, using fallback ETA: ${errorMessage}`);

      route = {
        provider: 'estimate',
        distanceMeters: Math.round(distanceKm * 1000),
        durationSeconds,
      };
    }

    const etaMinutes = Math.max(1, Math.ceil(route.durationSeconds / 60));
    const estimatedArrival = new Date(Date.now() + route.durationSeconds * 1000).toISOString();

    return {
      orderId,
      status: order.status,
      provider: route.provider,
      distanceMeters: route.distanceMeters,
      durationSeconds: route.durationSeconds,
      etaMinutes,
      estimatedArrival,
      from: { latitude: startLat, longitude: startLng },
      to: { latitude: destinationLat, longitude: destinationLng },
    };
  }

  private parseCoordinate(value: unknown): number | null {
    if (value === null || value === undefined) {
      return null;
    }
    const num = typeof value === 'number' ? value : parseFloat(String(value));
    return Number.isFinite(num) ? num : null;
  }

  private calculateDistanceKm(
    lat1: number,
    lon1: number,
    lat2: number,
    lon2: number,
  ): number {
    const toRad = (value: number) => (value * Math.PI) / 180;
    const earthRadiusKm = 6371;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
      Math.sin(dLat / 2) ** 2 +
      Math.cos(toRad(lat1)) *
        Math.cos(toRad(lat2)) *
        Math.sin(dLon / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return earthRadiusKm * c;
  }

  private estimateDurationSeconds(distanceKm: number, averageKph: number = 25): number {
    if (distanceKm <= 0 || averageKph <= 0) {
      return 60;
    }
    return Math.round((distanceKm / averageKph) * 3600);
  }

  private async requestRoute(coordinates: { lat: number; lng: number }[]) {
    const routingUrl = process.env.ROUTING_SERVICE_URL || 'http://localhost:9003/route';
    const provider = process.env.ROUTING_PROVIDER || 'osrm';
    const profile = process.env.ROUTING_PROFILE || 'driving';
    const payload = JSON.stringify({
      provider,
      profile,
      coordinates,
    });

    const response = await this.requestJson(routingUrl, payload);
    const distanceMeters = Number(response.distanceMeters);
    const durationSeconds = Number(response.durationSeconds);

    if (!Number.isFinite(distanceMeters) || !Number.isFinite(durationSeconds)) {
      throw new Error('Routing response missing distance or duration');
    }

    return {
      provider: response.provider || provider,
      distanceMeters,
      durationSeconds,
    };
  }

  private async requestJson(urlString: string, body: string): Promise<any> {
    const url = new URL(urlString);
    const transport = url.protocol === 'https:' ? https : http;

    return new Promise((resolve, reject) => {
      const req = transport.request(
        url,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Content-Length': Buffer.byteLength(body),
          },
        },
        (res) => {
          let data = '';
          res.on('data', (chunk) => {
            data += chunk;
          });
          res.on('end', () => {
            if (res.statusCode && res.statusCode >= 400) {
              return reject(new Error(`HTTP ${res.statusCode}: ${data}`));
            }
            try {
              resolve(JSON.parse(data));
            } catch (error) {
              reject(error);
            }
          });
        },
      );

      req.on('error', reject);
      req.write(body);
      req.end();
    });
  }

  async markOrderPickedUp(orderId: string, driverUserId: string) {
    const client = await this.db.connect();
    try {
      await client.query('BEGIN');

      const orderResult = await client.query(
        `SELECT o.id, o.order_number, o.status, o.assigned_driver_id, d.user_id as driver_user_id
         FROM orders o
         LEFT JOIN drivers d ON o.assigned_driver_id = d.id
         WHERE o.id = $1`,
        [orderId],
      );

      if (orderResult.rows.length === 0) {
        throw new NotFoundException('Order not found');
      }

      const order = orderResult.rows[0];

      if (order.driver_user_id !== driverUserId) {
        throw new ForbiddenException('You are not assigned to this order');
      }

      if (!OrderStateMachine.canTransition(order.status, OrderStatus.PICKED_UP)) {
        throw new BadRequestException(
          `Cannot mark order as picked up from status: ${order.status}`,
        );
      }

      await client.query(
        `UPDATE orders 
         SET status = $1, picked_up_at = NOW(), updated_at = NOW()
         WHERE id = $2`,
        [OrderStatus.PICKED_UP, orderId],
      );

      await client.query(
        `INSERT INTO order_status_history (order_id, status, changed_by, changed_at)
         VALUES ($1, $2, $3, NOW())`,
        [orderId, OrderStatus.PICKED_UP, driverUserId],
      );

      await client.query(
        `UPDATE driver_assignments 
         SET status = 'in_progress', updated_at = NOW()
         WHERE order_id = $1 AND status = 'accepted'`,
        [orderId],
      );

      await client.query('COMMIT');

      return {
        id: orderId,
        orderNumber: order.order_number,
        status: OrderStatus.PICKED_UP,
        message: 'Order marked as picked up',
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async markOrderInTransit(orderId: string, driverUserId: string) {
    const client = await this.db.connect();
    try {
      await client.query('BEGIN');

      const orderResult = await client.query(
        `SELECT o.id, o.order_number, o.status, o.assigned_driver_id, d.user_id as driver_user_id
         FROM orders o
         LEFT JOIN drivers d ON o.assigned_driver_id = d.id
         WHERE o.id = $1`,
        [orderId],
      );

      if (orderResult.rows.length === 0) {
        throw new NotFoundException('Order not found');
      }

      const order = orderResult.rows[0];

      if (order.driver_user_id !== driverUserId) {
        throw new ForbiddenException('You are not assigned to this order');
      }

      if (!OrderStateMachine.canTransition(order.status, OrderStatus.IN_TRANSIT)) {
        throw new BadRequestException(
          `Cannot mark order as in transit from status: ${order.status}`,
        );
      }

      await client.query(
        `UPDATE orders 
         SET status = $1, updated_at = NOW()
         WHERE id = $2`,
        [OrderStatus.IN_TRANSIT, orderId],
      );

      await client.query(
        `INSERT INTO order_status_history (order_id, status, changed_by, changed_at)
         VALUES ($1, $2, $3, NOW())`,
        [orderId, OrderStatus.IN_TRANSIT, driverUserId],
      );

      await client.query('COMMIT');

      return {
        id: orderId,
        orderNumber: order.order_number,
        status: OrderStatus.IN_TRANSIT,
        message: 'Order marked as in transit',
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async markOrderDelivered(orderId: string, driverUserId: string) {
    const client = await this.db.connect();
    try {
      await client.query('BEGIN');

      const orderResult = await client.query(
        `SELECT o.id, o.order_number, o.status, o.assigned_driver_id, o.total_cents, o.delivery_fee_cents,
                d.user_id as driver_user_id, d.id as driver_id
         FROM orders o
         LEFT JOIN drivers d ON o.assigned_driver_id = d.id
         WHERE o.id = $1`,
        [orderId],
      );

      if (orderResult.rows.length === 0) {
        throw new NotFoundException('Order not found');
      }

      const order = orderResult.rows[0];

      if (order.driver_user_id !== driverUserId) {
        throw new ForbiddenException('You are not assigned to this order');
      }

      if (!OrderStateMachine.canTransition(order.status, OrderStatus.DELIVERED)) {
        throw new BadRequestException(
          `Cannot mark order as delivered from status: ${order.status}`,
        );
      }

      await client.query(
        `UPDATE orders 
         SET status = $1, delivered_at = NOW(), actual_delivery_time = NOW(), updated_at = NOW()
         WHERE id = $2`,
        [OrderStatus.DELIVERED, orderId],
      );

      await client.query(
        `INSERT INTO order_status_history (order_id, status, changed_by, changed_at)
         VALUES ($1, $2, $3, NOW())`,
        [orderId, OrderStatus.DELIVERED, driverUserId],
      );

      await client.query(
        `UPDATE driver_assignments 
         SET status = 'completed', updated_at = NOW()
         WHERE order_id = $1`,
        [orderId],
      );

      const existingLedger = await client.query(
        `SELECT id FROM driver_ledger WHERE order_id = $1`,
        [orderId],
      );

      if (existingLedger.rows.length === 0) {
        const deliveryFeeCents = order.delivery_fee_cents || 500;
        const tipCents = 0;

        await client.query(
          `INSERT INTO driver_ledger (driver_id, order_id, delivery_fee_cents, tip_cents, total_earning_cents, payout_status)
           VALUES ($1, $2, $3, $4, $5, 'pending')`,
          [order.driver_id, orderId, deliveryFeeCents, tipCents, deliveryFeeCents + tipCents],
        );
      }

      await client.query('COMMIT');

      this.logger.log(`Order ${order.order_number} delivered by driver ${driverUserId}`);

      return {
        id: orderId,
        orderNumber: order.order_number,
        status: OrderStatus.DELIVERED,
        message: 'Order marked as delivered',
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}
