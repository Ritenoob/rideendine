[{"@nestjs/testing": "import { AuthService"}, {"@nestjs/jwt": "import { ConflictException", "@nestjs/common": "import { UserRole"}, {"hash": "jest.fn()", "compare": "jest.fn()"}, {"request": "jest.fn()"}, {"service": "AuthService;\n\n  // Mock database pool\n  const mockPool = {\n    query: jest.fn()", "connect": "jest.fn()"}, {"query": "jest.fn()", "release": "jest.fn()"}, {"sign": "jest.fn()", "verify": "jest.fn()"}, {"sub": "user-id", "email": "test@example.com", "role": "UserRole.CUSTOMER"}, {"id": "user-id", "email": "test@example.com", "password_hash": "hashed-password", "role": "UserRole.CUSTOMER", "is_verified": true, "first_name": "Test", "last_name": "User", "phone": "+1234567890", "avatar_url": null}, {"module": "TestingModule = await Test.createTestingModule({\n      providers: [\n        AuthService", "provide": "DATABASE_POOL", "useValue": "mockPool"}, {"provide": "JwtService", "useValue": "mockJwtService"}, {"email": "test@example.com", "password": "Test1234!", "role": "UserRole.CUSTOMER", "firstName": "Test", "lastName": "User", "phone": "+1234567890"}, {"Mock": "No existing user\n      mockPool.query.mockResolvedValueOnce({ rows: []"}, {"rows": [{"id": "user-id", "email": "registerDto.email", "role": "registerDto.role", "is_verified": false, "created_at": "new Date()"}]}, {"rows": []}, {"rows": []}, ["registerDto.email]);\n      expect(mockClient.query).toHaveBeenCalledWith('BEGIN');\n      expect(mockClient.query).toHaveBeenCalledWith('COMMIT');\n    });\n\n    it('should throw ConflictException if email already exists', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [{ id: 'existing-id' }] });\n\n      await expect(service.register(registerDto)).rejects.toThrow(ConflictException);\n      await expect(service.register(registerDto)).rejects.toThrow('Email already registered');\n    });\n\n    it('should hash password with bcrypt', async () => {\n      const bcrypt = require('bcrypt');\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n      mockPool.connect.mockResolvedValueOnce(mockClient);\n      mockClient.query.mockResolvedValueOnce({\n        rows: [{ id: 'user-id', email: registerDto.email, role: registerDto.role, is_verified: false, created_at: new Date() }],\n      });\n      mockClient.query.mockResolvedValueOnce({ rows: [] });\n      mockClient.query.mockResolvedValueOnce({ rows: [] });\n\n      await service.register(registerDto);\n\n      expect(bcrypt.hash).toHaveBeenCalledWith(registerDto.password, 10);\n    });\n\n    it('should create role-specific record for chef', async () => {\n      const chefDto = { ...registerDto, role: UserRole.CHEF };\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n      mockPool.connect.mockResolvedValueOnce(mockClient);\n      mockClient.query.mockResolvedValueOnce({\n        rows: [{ id: 'user-id', email: chefDto.email, role: chefDto.role, is_verified: false, created_at: new Date() }],\n      });\n      mockClient.query.mockResolvedValueOnce({ rows: [] });\n      mockClient.query.mockResolvedValueOnce({ rows: [] });\n\n      await service.register(chefDto);\n\n      const chefInsertCall = mockClient.query.mock.calls.find(call =>\n        call[0].includes('INSERT INTO chefs')\n      );\n      expect(chefInsertCall).toBeDefined();\n    });\n\n    it('should create role-specific record for driver', async () => {\n      const driverDto = { ...registerDto, role: UserRole.DRIVER };\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n      mockPool.connect.mockResolvedValueOnce(mockClient);\n      mockClient.query.mockResolvedValueOnce({\n        rows: [{ id: 'user-id', email: driverDto.email, role: driverDto.role, is_verified: false, created_at: new Date() }],\n      });\n      mockClient.query.mockResolvedValueOnce({ rows: [] });\n      mockClient.query.mockResolvedValueOnce({ rows: [] });\n\n      await service.register(driverDto);\n\n      const driverInsertCall = mockClient.query.mock.calls.find(call =>\n        call[0].includes('INSERT INTO drivers')\n      );\n      expect(driverInsertCall).toBeDefined();\n    });\n\n    it('should rollback transaction on error', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n      mockPool.connect.mockResolvedValueOnce(mockClient);\n      mockClient.query.mockRejectedValueOnce(new Error('Database error'));\n\n      await expect(service.register(registerDto)).rejects.toThrow();\n      expect(mockClient.query).toHaveBeenCalledWith('ROLLBACK');\n    });\n\n    it('should not insert profile if no profile data provided', async () => {\n      const minimalDto = {\n        email: 'test@example.com',\n        password: 'Test1234!',\n        role: UserRole.CUSTOMER,\n      };\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n      mockPool.connect.mockResolvedValueOnce(mockClient);\n      mockClient.query.mockResolvedValueOnce({\n        rows: [{ id: 'user-id', email: minimalDto.email, role: minimalDto.role, is_verified: false, created_at: new Date() }],\n      });\n      mockClient.query.mockResolvedValueOnce({ rows: [] });\n\n      await service.register(minimalDto);\n\n      const profileInsertCall = mockClient.query.mock.calls.find(call =>\n        call[0].includes('INSERT INTO user_profiles')\n      );\n      expect(profileInsertCall).toBeUndefined();\n    });\n  });\n\n  describe('login', () => {\n    const loginDto = {\n      email: 'test@example.com',\n      password: 'Test1234!',\n    };\n\n    it('should successfully login with valid credentials', async () => {\n      const bcrypt = require('bcrypt');\n      mockPool.query.mockResolvedValueOnce({ rows: [mockUser] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] }); // Insert refresh token\n      bcrypt.compare.mockResolvedValueOnce(true);\n      mockJwtService.sign.mockReturnValueOnce('access-token').mockReturnValueOnce('refresh-token');\n\n      const result = await service.login(loginDto);\n\n      expect(result).toHaveProperty('accessToken');\n      expect(result).toHaveProperty('refreshToken');\n      expect(result).toHaveProperty('user');\n      expect(result.user.email).toBe(loginDto.email);\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('SELECT u.*, p.first_name'),\n        [loginDto.email]\n      );\n    });\n\n    it('should throw UnauthorizedException if user not found', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await expect(service.login(loginDto)).rejects.toThrow(UnauthorizedException);\n      await expect(service.login(loginDto)).rejects.toThrow('Invalid credentials');\n    });\n\n    it('should throw UnauthorizedException if password is invalid', async () => {\n      const bcrypt = require('bcrypt');\n      mockPool.query.mockResolvedValueOnce({ rows: [mockUser] });\n      bcrypt.compare.mockResolvedValueOnce(false);\n\n      await expect(service.login(loginDto)).rejects.toThrow(UnauthorizedException);\n      await expect(service.login(loginDto)).rejects.toThrow('Invalid credentials');\n    });\n\n    it('should generate both access and refresh tokens', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [mockUser] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] }); // Insert refresh token\n      mockJwtService.sign.mockReturnValueOnce('access-token').mockReturnValueOnce('refresh-token');\n\n      const result = await service.login(loginDto);\n\n      expect(result.accessToken).toBe('access-token');\n      expect(result.refreshToken).toBe('refresh-token');\n      expect(mockJwtService.sign).toHaveBeenCalledTimes(2);\n    });\n\n    it('should include user profile in response', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [mockUser] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] }); // Insert refresh token\n      mockJwtService.sign.mockReturnValueOnce('access-token').mockReturnValueOnce('refresh-token');\n\n      const result = await service.login(loginDto);\n\n      expect(result.user.profile).toBeDefined();\n      expect(result.user.profile.firstName).toBe('Test');\n      expect(result.user.profile.lastName).toBe('User');\n      expect(result.user.profile.phone).toBe('+1234567890');\n    });\n  });\n\n  describe('refreshTokens', () => {\n    const refreshTokenDto = {\n      refreshToken: 'valid-refresh-token',\n    };\n\n    it('should successfully refresh tokens with valid refresh token', async () => {\n      mockJwtService.verify.mockReturnValueOnce(mockPayload);\n      mockPool.query.mockResolvedValueOnce({ rows: [{ token: refreshTokenDto.refreshToken }] });\n      mockPool.query.mockResolvedValueOnce({ rows: [mockUser] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n      mockJwtService.sign.mockReturnValueOnce('new-access-token').mockReturnValueOnce('new-refresh-token');\n\n      const result = await service.refreshTokens(refreshTokenDto);\n\n      expect(result).toHaveProperty('accessToken');\n      expect(result).toHaveProperty('refreshToken');\n      expect(mockPool.query).toHaveBeenCalledWith(\n        'DELETE FROM refresh_tokens WHERE token = $1',\n        [refreshTokenDto.refreshToken]\n      );\n    });\n\n    it('should throw UnauthorizedException if refresh token is invalid', async () => {\n      mockJwtService.verify.mockImplementationOnce(() => {\n        throw new Error('Invalid token');\n      });\n\n      await expect(service.refreshTokens(refreshTokenDto)).rejects.toThrow(UnauthorizedException);\n    });\n\n    it('should throw UnauthorizedException if token not found in database', async () => {\n      mockJwtService.verify.mockReturnValueOnce(mockPayload);\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await expect(service.refreshTokens(refreshTokenDto)).rejects.toThrow(UnauthorizedException);\n    });\n\n    it('should throw UnauthorizedException if user not found', async () => {\n      mockJwtService.verify.mockReturnValueOnce(mockPayload);\n      mockPool.query.mockResolvedValueOnce({ rows: [{ token: refreshTokenDto.refreshToken }] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await expect(service.refreshTokens(refreshTokenDto)).rejects.toThrow(UnauthorizedException);\n    });\n\n    it('should delete old refresh token', async () => {\n      mockJwtService.verify.mockReturnValueOnce(mockPayload);\n      mockPool.query.mockResolvedValueOnce({ rows: [{ token: refreshTokenDto.refreshToken }] });\n      mockPool.query.mockResolvedValueOnce({ rows: [mockUser] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n      mockJwtService.sign.mockReturnValueOnce('new-access-token').mockReturnValueOnce('new-refresh-token');\n\n      await service.refreshTokens(refreshTokenDto);\n\n      expect(mockPool.query).toHaveBeenCalledWith(\n        'DELETE FROM refresh_tokens WHERE token = $1',\n        [refreshTokenDto.refreshToken]\n      );\n    });\n  });\n\n  describe('verifyEmail', () => {\n    const verifyEmailDto = {\n      token: 'valid-verification-token',\n    };\n\n    it('should successfully verify email with valid token', async () => {\n      mockPool.query.mockResolvedValueOnce({\n        rows: [{ id: 'user-id', email: 'test@example.com' }],\n      });\n\n      const result = await service.verifyEmail(verifyEmailDto);\n\n      expect(result).toHaveProperty('message');\n      expect(result.message).toBe('Email verified successfully');\n      expect(result).toHaveProperty('user');\n      expect(mockPool.query).toHaveBeenCalledWith(\n        expect.stringContaining('UPDATE users SET is_verified = TRUE'),\n        [verifyEmailDto.token]\n      );\n    });\n\n    it('should throw UnauthorizedException if token is invalid', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await expect(service.verifyEmail(verifyEmailDto)).rejects.toThrow(UnauthorizedException);\n      await expect(service.verifyEmail(verifyEmailDto)).rejects.toThrow('Invalid verification token');\n    });\n  });\n\n  describe('forgotPassword', () => {\n    const forgotPasswordDto = {\n      email: 'test@example.com',\n    };\n\n    it('should generate reset token and update user', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      const result = await service.forgotPassword(forgotPasswordDto);\n\n      expect(result).toHaveProperty('message');\n      expect(result.message).toBe('Password reset email sent');\n      expect(mockPool.query).toHaveBeenCalledWith(\n        'UPDATE users SET reset_token = $1, reset_token_expires = $2 WHERE email = $3',\n        expect.arrayContaining([\n          expect.any(String),\n          expect.any(Date),\n          forgotPasswordDto.email\n        ])\n      );\n    });\n\n    it('should set reset token expiry to 1 hour', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await service.forgotPassword(forgotPasswordDto);\n\n      const updateCall = mockPool.query.mock.calls.find(call =>\n        call[0].includes('UPDATE users SET reset_token =')\n      );\n      expect(updateCall).toBeDefined();\n      const expiresAt = updateCall[1][1]; // Second param in array [resetToken, expiresAt, email]\n      const expectedExpiry = new Date(Date.now() + 3600000);\n      expect(expiresAt.getTime()).toBeCloseTo(expectedExpiry.getTime(), -3);\n    });\n  });\n\n  describe('resetPassword', () => {\n    const resetPasswordDto = {\n      token: 'valid-reset-token',\n      newPassword: 'NewPassword123!',\n    };\n\n    it('should successfully reset password with valid token', async () => {\n      const bcrypt = require('bcrypt');\n      mockPool.query.mockResolvedValueOnce({ rows: [{ id: 'user-id' }] }); // SELECT user by reset token\n      mockPool.query.mockResolvedValueOnce({ rows: [] }); // UPDATE password\n      mockPool.query.mockResolvedValueOnce({ rows: [] }); // DELETE refresh tokens\n\n      const result = await service.resetPassword(resetPasswordDto);\n\n      expect(result).toHaveProperty('message');\n      expect(result.message).toBe('Password reset successfully');\n      expect(mockPool.query).toHaveBeenCalledWith(\n        'UPDATE users SET password_hash = $1, reset_token = NULL, reset_token_expires = NULL WHERE id = $2',\n        expect.arrayContaining([expect.any(String), 'user-id'])\n      );\n      expect(bcrypt.hash).toHaveBeenCalledWith(resetPasswordDto.newPassword, 10);\n    });\n\n    it('should throw UnauthorizedException if token is invalid', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await expect(service.resetPassword(resetPasswordDto)).rejects.toThrow(UnauthorizedException);\n      await expect(service.resetPassword(resetPasswordDto)).rejects.toThrow('Invalid or expired reset token');\n    });\n\n    it('should hash new password', async () => {\n      const bcrypt = require('bcrypt');\n      mockPool.query.mockResolvedValueOnce({ rows: [{ id: 'user-id' }] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await service.resetPassword(resetPasswordDto);\n\n      expect(bcrypt.hash).toHaveBeenCalledWith(resetPasswordDto.newPassword, 10);\n    });\n\n    it('should delete all refresh tokens for user', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [{ id: 'user-id' }] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await service.resetPassword(resetPasswordDto);\n\n      expect(mockPool.query).toHaveBeenCalledWith(\n        'DELETE FROM refresh_tokens WHERE user_id = $1',\n        ['user-id']\n      );\n    });\n  });\n\n  describe('logout', () => {\n    it('should successfully logout user', async () => {\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      const result = await service.logout('user-id', 'refresh-token');\n\n      expect(result).toHaveProperty('message');\n      expect(result.message).toBe('Logged out successfully');\n      expect(mockPool.query).toHaveBeenCalledWith(\n        'DELETE FROM refresh_tokens WHERE user_id = $1 AND token = $2',\n        ['user-id', 'refresh-token']\n      );\n    });\n  });\n\n  describe('generateTokens (private)', () => {\n    const mockUser = {\n      id: 'user-id',\n      email: 'test@example.com',\n      password_hash: 'hashed-password',\n      role: UserRole.CUSTOMER,\n      is_verified: true,\n      verification_token: null,\n      reset_token: null,\n      reset_token_expires: null,\n      created_at: new Date(),\n      updated_at: new Date(),\n    };\n\n    it('should generate access token with correct payload', async () => {\n      mockJwtService.sign.mockReturnValueOnce('access-token');\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await service['generateTokens'](mockUser);\n\n      expect(mockJwtService.sign).toHaveBeenCalledWith({\n        sub: mockUser.id,\n        email: mockUser.email,\n        role: mockUser.role,\n      });\n    });\n\n    it('should generate refresh token with correct secret and expiry', async () => {\n      mockJwtService.sign.mockReturnValueOnce('access-token').mockReturnValueOnce('refresh-token');\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await service['generateTokens'](mockUser);\n\n      expect(mockJwtService.sign).toHaveBeenCalledWith(\n        {\n          sub: mockUser.id,\n          email: mockUser.email,\n          role: mockUser.role,\n        },\n        {\n          secret: process.env.REFRESH_TOKEN_SECRET,\n          expiresIn: process.env.REFRESH_TOKEN_EXPIRES_IN || '7d',\n        }\n      );\n    });\n\n    it('should store refresh token in database', async () => {\n      mockJwtService.sign.mockReturnValueOnce('access-token').mockReturnValueOnce('refresh-token');\n      mockPool.query.mockResolvedValueOnce({ rows: [] });\n\n      await service['generateTokens'](mockUser);\n\n      expect(mockPool.query).toHaveBeenCalledWith(\n        'INSERT INTO refresh_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)',\n        [mockUser.id, 'refresh-token', expect.any(Date)]\n      );\n    });\n  });\n});"]]
